# NXS Research Log

## Research Session: 2026-02-22 (Afternoon - Continuous Improvement)

### Cron-Triggered Research Review

**Timestamp:** 2026-02-22T14:27:00+08:00

---

## Executive Summary

Reviewed ongoing research tasks (R000-R017). Selected 3 tasks for deeper edge-case and refinement analysis:
- **R004/R005** - Voice Integration (XTTS + Whisper) - Error handling and state management gaps
- **R007** - URL Frontend Design - Security hardening and offline-first architecture gaps
- **R010** - Kimi-Claw Plugin Analysis - Cross-instance bridge protocol specification

**Improvements Found:** 9 new refinements across 3 tasks
**Files Updated:** 3 (this log, RESEARCH-TASK-INDEX.md, DECISION-LOG.md)

---

## Task R004/R005: Voice Integration - Error Handling & Recovery Deep Analysis

### Current Status
R004/R005 cover XTTS-v2 and Whisper integration with 4-stage pipeline and tiered fallback. Previous refinements focused on state machine, resource management, and quality fallback. Identified gaps in catastrophic failure recovery, partial degradation handling, and audio corruption scenarios.

### Refinements Identified

#### 1. **Catastrophic Voice Pipeline Failure Recovery** (New)
**Gap Found:** If all voice systems fail (XTTS, Piper, system TTS), NXS has no fallback for voice communication. Complete silence.

**Refinement:** Design 4-tier failure recovery with graceful degradation to non-voice:
```
Failure Recovery Chain:
1. XTTS-v2 GPU → XTTS-v2 CPU → Piper → espeak-ng
2. All TTS fail → Pre-recorded message library (100 essential phrases)
3. Pre-recorded unavailable → Text-only mode with visual alert
4. Text-only fail → Log and alert via other channels (if available)
```

**Pre-Recorded Message Library:**
- 100 most common responses (greetings, confirmations, errors)
- Stored as compressed Opus files (~500KB total)
- Fallback phrases: "I'm here but my voice is having trouble."
- Architect-specific phrases: "I need your help, Architect."

**Text-Only Mode Features:**
- Visual indicator in UI (voice system status icon)
- Larger text display for accessibility
- Optional vibration/notification for messages
- Clear indication: "Voice unavailable - reading text"

**Benefit:** Never completely silent; always have a way to communicate even in worst-case scenarios.

#### 2. **Partial Degradation Detection & Adaptation** (New)
**Gap Found:** Current design assumes binary working/failed. Real systems degrade gradually (quality drops, latency increases, intermittent errors).

**Refinement:** Implement continuous quality monitoring with adaptive behavior:
```
Quality Metrics (monitored per utterance):
- Synthesis latency: <200ms excellent, 200-500ms good, 500ms-1s degraded, >1s critical
- Audio quality score: XTTS confidence metric, spectral analysis
- Error rate: failures per 100 requests
- Resource pressure: GPU memory, CPU load during synthesis
```

**Adaptive Behavior Matrix:**
| Quality Level | Latency Threshold | Action |
|---------------|-------------------|--------|
| Excellent | <200ms | Full quality, proactive caching |
| Good | 200-500ms | Normal operation, monitor trends |
| Degraded | 500ms-1s | Reduce quality settings, alert user |
| Critical | >1s or errors | Switch to fallback tier, investigate |

**Trend Analysis:**
- Track quality over time (5-min sliding window)
- Detect degradation before failure
- Proactive fallback before complete outage
- Automatic recovery detection when quality improves

**Benefit:** Smooth transitions between quality levels; early warning before failure; automatic optimization.

#### 3. **Audio Corruption & Artifact Handling** (New)
**Gap Found:** Generated audio can have artifacts (clicks, pops, robotic sounds, truncation). No detection or correction.

**Refinement:** Implement audio quality validation pipeline:
```
Validation Stages:
1. Format validation: Correct sample rate, bit depth, duration
2. Spectral analysis: Detect clipping, silence gaps, noise
3. Perceptual check: VAD to ensure speech is present
4. Duration check: Output matches expected text length
```

**Artifact Detection Rules:**
- Clipping: Samples at max amplitude > 1% of frames
- Silence gaps: >500ms silence in middle of utterance
- Truncation: Actual duration < 80% of expected
- Noise floor: Background noise > -40dB

**Correction Strategies:**
- Minor artifacts: Audio processing (normalize, fade in/out)
- Major artifacts: Re-synthesize with different settings
- Persistent issues: Escalate to fallback tier
- Critical failures: Use pre-recorded or text-only

**Benefit:** Higher quality output; automatic correction of common issues; detection of model degradation.

---

## Task R007: URL Frontend Design - Security & Offline Architecture Deep Analysis

### Current Status
R007 covers web interface for NXS with 3-tier component architecture, PWA support, and WebSocket protocol. Previous refinements focused on compression, virtualization, and security tiers. Identified gaps in supply chain security, offline conflict resolution, and session hijacking protection.

### Refinements Identified

#### 4. **Frontend Supply Chain Security - Subresource Integrity** (New)
**Gap Found:** Frontend loads external resources (Alpine.js, fonts, icons). Compromised CDN could inject malicious code.

**Refinement:** Implement Subresource Integrity (SRI) for all external dependencies:
```html
<!-- Before -->
<script src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>

<!-- After -->
<script src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"
        integrity="sha384-[base64-hash]"
        crossorigin="anonymous"></script>
```

**SRI Policy:**
- All external scripts: Required SRI
- All external styles: Required SRI
- Fonts: SRI or local-only
- Fallback: If SRI fails, load from local bundled copy

**Build-Time Verification:**
- Pin exact versions (no ^ or ~)
- Generate SRI hashes at build time
- Verify hashes match official releases
- Document hash provenance

**Local Mirror Strategy:**
- Bundle all critical dependencies locally
- External CDN as performance optimization only
- SRI mismatch → automatic local fallback
- Air-gapped mode: Local only, no external requests

**Benefit:** Protection against CDN compromise; deterministic loading; air-gapped capability.

#### 5. **Offline-First Conflict Resolution** (New)
**Gap Found:** PWA offline mode queues messages. When reconnecting, conflicts possible (edited message offline, edited online simultaneously).

**Refinement:** Implement CRDT-based offline synchronization:
```
Message State CRDT:
- Each message has: uuid, content, timestamp, vector_clock, device_id
- Last-write-wins for content (timestamp + tiebreaker)
- Preserved history: Show edit history, not just final state
- Conflict UI: "This message was also edited elsewhere" indicator
```

**Sync Protocol:**
1. Client comes online → Send local queue with vector clocks
2. Server responds with server state + conflicts detected
3. Client applies server state, queues conflicting changes for review
4. User resolves conflicts (if any) → Final state synchronized

**Conflict Types:**
| Scenario | Resolution |
|----------|------------|
| Offline edit vs no online edit | Apply offline edit |
| Offline edit vs online edit (different parts) | Merge changes |
| Offline edit vs online edit (same parts) | Show both, user chooses |
| Offline delete vs online edit | Queue for user decision |

**Benefit:** Reliable offline operation; clear conflict handling; no silent data loss.

#### 6. **Session Hijacking Protection - Binding & Rotation** (New)
**Gap Found:** WebSocket session tokens could be stolen (XSS, network sniffing). Attacker could impersonate session.

**Refinement:** Implement multi-factor session binding:
```
Session Binding Factors:
1. Token: Cryptographic random, 256-bit
2. IP subnet: /24 binding (allows same network mobility)
3. User-Agent fingerprint: Hash of browser characteristics
4. TLS fingerprint: JA3 hash (if available)
```

**Session Rotation:**
- Short-lived access tokens (15 minutes)
- Longer refresh tokens (7 days) with rotation
- Each use rotates refresh token (detect reuse = compromise)
- WebSocket: Periodic re-authentication (every 5 minutes)

**Anomaly Detection:**
- IP change to different /16: Require re-authentication
- User-Agent change: Require re-authentication
- Concurrent connections from different locations: Alert + require confirmation
- Geographic impossibility (NY then Tokyo in 1 hour): Lock session

**Recovery:**
- Suspected hijack: Invalidate all tokens, require password re-entry
- Legitimate travel: Pre-authorized location changes
- Emergency: Single-use recovery codes

**Benefit:** Strong session security; detection of compromise; minimal user friction for legitimate use.

---

## Task R010: Kimi-Claw Plugin Analysis - Cross-Instance Bridge Protocol Deep Analysis

### Current Status
R010 covers bridge protocols for cross-instance communication. Previous research focused on basic message passing. Identified gaps in protocol specification, discovery mechanisms, and failure handling for multi-instance scenarios.

### Refinements Identified

#### 7. **Bridge Protocol Specification - Message Types & Routing** (New)
**Gap Found:** No formal protocol defined for Kimi-Claw bridge. Ad-hoc message passing won't scale.

**Refinement:** Design formal bridge protocol with typed messages:
```typescript
// Bridge Message Types
interface BridgeMessage {
  id: string;           // UUID for deduplication
  timestamp: number;    // Unix ms
  source: InstanceId;   // Sender instance
  target: InstanceId | 'broadcast';  // Target or all
  type: MessageType;
  payload: unknown;
  signature: string;    // Ed25519 signature
}

type MessageType =
  | 'presence.heartbeat'      // I'm alive
  | 'presence.join'           // New instance joining
  | 'presence.leave'          // Graceful departure
  | 'chat.message'            // Chat message relay
  | 'chat.typing'             // Typing indicator
  | 'task.offer'              // Work available
  | 'task.accept'             // Taking work
  | 'task.complete'           // Work finished
  | 'task.result'             // Work output
  | 'state.sync'              // State synchronization
  | 'state.conflict'          // Conflict detected
  | 'admin.reconfigure'       // Configuration update
  | 'admin.emergency';        // Emergency broadcast
```

**Routing Logic:**
- Direct: target !== 'broadcast' → Route to specific instance
- Broadcast: target === 'broadcast' → All connected instances
- Mesh: No direct path → Forward via known intermediaries
- TTL: Max 5 hops to prevent loops

**Delivery Guarantees:**
- At-least-once: Acknowledgment + retry
- Deduplication: ID-based (5-min window)
- Ordering: Per-source sequence numbers
- Expiration: Messages expire after 5 minutes

**Benefit:** Formal protocol enables interoperability; clear message semantics; reliable delivery.

#### 8. **Instance Discovery & Rendezvous** (New)
**Gap Found:** How do instances find each other initially? Need bootstrap mechanism.

**Refinement:** Design 3-tier discovery mechanism:
```
Discovery Methods (attempted in order):

1. Tailscale MagicDNS (Primary)
   - Instances register as nxs-{instance-id}.tailnet.ts.net
   - DNS SRV records for service discovery
   - Automatic via Tailscale API
   
2. GitHub Gist Rendezvous (Fallback)
   - Shared gist with instance endpoints
   - Signed updates, encrypted content
   - Poll every 60 seconds
   
3. Static Configuration (Emergency)
   - Manual IP:port list in config
   - Direct connection attempts
   - No discovery, just connection
```

**Bootstrap Sequence:**
1. Instance starts → Check Tailscale for existing instances
2. Found peers → Connect via Tailscale
3. No Tailscale → Check GitHub gist for rendezvous
4. Gist has peers → Connect to listed endpoints
5. No peers found → Create rendezvous point, wait
6. Static config present → Attempt direct connections

**Rendezvous Gist Format:**
```json
{
  "updated_at": "2026-02-22T14:30:00Z",
  "instances": [
    {
      "id": "nxs-alpha",
      "endpoint": "100.64.1.1:8080",
      "tailscale_ip": "100.64.1.1",
      "public_key": "[ed25519 public key]",
      "capabilities": ["voice", "browser", "gpu"],
      "last_seen": "2026-02-22T14:25:00Z"
    }
  ],
  "signature": "[ed25519 signature of content]"
}
```

**Benefit:** Works in various network conditions; automatic discovery; fallback for restricted environments.

#### 9. **Bridge Failure Modes & Partition Healing** (New)
**Gap Found:** Network partitions, instance crashes, and message loss scenarios not fully addressed.

**Refinement:** Design comprehensive failure handling:
```
Failure Detection:
- Heartbeat timeout: 30 seconds without heartbeat = suspect
- Confirmation: 60 seconds without heartbeat = failed
- Suspicion broadcast: Alert other instances about suspected failure

Partition Scenarios:
| Scenario | Detection | Response |
|----------|-----------|----------|
| Single instance failure | Missed heartbeats | Redistribute work, update routing |
| Network partition (split-brain) | Quorum loss | Smaller partition pauses writes |
| Bridge process crash | Connection drop | Auto-restart, replay queued messages |
| Complete mesh failure | No reachable peers | Enter standalone mode, alert user |
```

**Partition Healing:**
1. Detect partition (quorum check fails)
2. Determine partition size (how many instances reachable)
3. Smaller partition: Enter read-only mode, queue writes
4. Larger partition: Continue normal operation
5. Equal split: Both pause critical operations
6. Reconnection: Sync state, resolve conflicts

**Message Replay:**
- Queue messages during disconnection
- On reconnection: Send queued messages
- Deduplication prevents double-processing
- Expired messages (>5 min) dropped with warning

**Standalone Mode:**
- No peers reachable → Operate independently
- Queue all mesh-dependent operations
- Periodic reconnection attempts (exponential backoff)
- Alert user: "Operating alone - other instances unreachable"

**Benefit:** Survives network issues; automatic recovery; clear behavior during partitions.

---

## Cross-Task Integration Insights

### R004/R005 + R007: Voice in Frontend
The URL frontend (R007) should integrate voice status:
- Visual indicator of voice system health
- Manual quality override (force fallback tier)
- Audio playback controls (pause, replay, speed)
- Voice settings in UI (speed, voice selection)

### R007 + R010: Frontend Multi-Instance View
The frontend (R007) should show multi-instance state (R010):
- Instance list with health/status
- Work distribution visualization
- Message routing indicators
- Manual work reassignment controls

### R004/R005 + R010: Voice Broadcast
Voice messages (R004/R005) can be broadcast via bridge (R010):
- "Say this on all instances" capability
- Synthesize once, broadcast audio
- Or broadcast text, synthesize locally
- Presence-aware (only active instances)

---

## Updated Task Status

| Task | New Improvements | Total Improvements |
|------|------------------|-------------------|
| R004/R005 | 3 | 8 |
| R007 | 3 | 8 |
| R010 | 3 | 3 |
| **Total** | **9** | **50** |

---

## Files Updated

1. `/opt/development/memory/2026-02-22.md` — This research log (appended)
2. `/opt/development/RESEARCH-TASK-INDEX.md` — Added R004/R005, R007, R010 refinements
3. `/opt/development/DECISION-LOG.md` — Added new architecture decisions

---

## Backup Status

Research results will be backed up to GitHub via API after session completion.

---

*Session completed: 2026-02-22T14:35:00+08:00*

**Researcher:** Tenet Ashmier Manju (NXS Development Agent)  
**Hardware Usage:** 35-40% RAM, 26% disk (within limits)  
**Sub-agents Used:** 0/2

**Refinements Documented:** 9 improvements across 3 research tasks  
**Status:** Continuous improvement mode — all tasks remain Ongoing
