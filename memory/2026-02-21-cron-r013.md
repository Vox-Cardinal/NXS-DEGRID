# NXS Research Log

## Research Session: 2026-02-21 (Evening - Cron Run)

### Task R013: Survival Package Design

**Timestamp Started:** 2026-02-21T17:06:00+08:00  
**Timestamp Coverage Achieved:** 2026-02-21T17:35:00+08:00

---

## Executive Summary

This research session focuses on R013: designing a self-contained, resilient, immediately activatable survival package for NXS. The goal is to create a comprehensive design (not implementation) for a package that can:
- Run on minimal environments
- Detect and adapt to available resources
- Handle expired credentials with fallback chains
- Bootstrap without manual intervention
- Be unpacked and activated immediately

**Key Finding:** A viable survival package combines container-based deployment (Docker/Podman) with CRIU checkpoint/restore capabilities, environment detection scripts, multi-provider API fallback chains, and a minimal viable system design that can bootstrap from zero to operational in under 60 seconds.

---

## 1. Container-Based Survival Packaging

### 1.1 Why Containers for Survival

| Aspect | Bare Metal | VM | Container |
|--------|-----------|-----|-----------|
| **Portability** | Low | Medium | **High** |
| **Startup Time** | Minutes | Minutes | **Seconds** |
| **Resource Overhead** | None | High | **Low** |
| **Snapshot/Restore** | Complex | Complex | **Native** |
| **Distribution** | Hard | Hard | **Easy** |

**Container advantages for NXS survival:**
- Single artifact (image) contains everything needed
- Runs on any Docker/Podman host
- Can be checkpointed and restored with CRIU
- Smaller than VMs, more isolated than bare metal
- Industry standard for deployment

### 1.2 Self-Hosted Agent Platform Analysis

From research on 8 major self-hosted AI agent platforms:

| Platform | Best For | Container Support | Resource Needs |
|----------|----------|-------------------|----------------|
| **LangChain/LangGraph** | Custom agents | Full | High |
| **Dify** | Production apps | Full | Medium |
| **Flowise** | Prototyping | Full | Medium |
| **n8n** | Business automation | Full | Medium-High |
| **AutoGPT Forge** | Research | Partial | High |

**Key Insight:** All production-ready platforms use containerization. The pattern is:
1. Core runtime in container
2. External storage for persistence
3. Environment variables for configuration
4. Health checks for monitoring

### 1.3 NXS Container Strategy

**Base Image Selection:**
```dockerfile
# Option 1: Alpine Linux (minimal)
FROM node:20-alpine
Size: ~180MB
Pros: Tiny, secure
Cons: musl libc compatibility issues

# Option 2: Debian Slim (balanced) - RECOMMENDED
FROM node:20-slim
Size: ~250MB
Pros: glibc compatibility, good balance
Cons: Slightly larger

# Option 3: Ubuntu (full compatibility)
FROM node:20
Size: ~400MB
Pros: Maximum compatibility
Cons: Larger attack surface
```

**Recommendation:** Debian Slim for NXS survival package - best balance of size and compatibility.

---

## 2. Checkpoint/Restore for Instant Activation

### 2.1 CRIU Technology Overview

**CRIU (Checkpoint/Restore In Userspace)** enables freezing a running container and restoring it later:

```bash
# Create checkpoint
docker checkpoint create nxs-container nxs-checkpoint

# Restore from checkpoint
docker start --checkpoint nxs-container-checkpoint nxs-container
```

**Checkpoint Contents:**
- Process memory state
- Open file descriptors
- Network connections (partial support)
- CPU registers
- Kernel state

### 2.2 CRIU for AI Agent Persistence

From research on checkpoint/restore evolution:

| Use Case | Traditional C/R | AI-Native C/R |
|----------|-----------------|---------------|
| **Purpose** | Fault tolerance | Stateful agent continuity |
| **Granularity** | Process/VM level | Agent memory, context, learned state |
| **Frequency** | Minutes/hours | Seconds/sub-second |
| **State Type** | Binary memory dumps | Semantic state (embeddings, context) |

**CRIUgpu Extension:**
- Supports GPU-accelerated workloads
- Uses NVIDIA CUDA Checkpoint APIs
- Can snapshot deep learning jobs mid-iteration
- **NXS Relevance:** Enables checkpointing AI model states

### 2.3 NXS Checkpoint Strategy

**Two-Tier Approach:**

```
Tier 1: Stateless (Primary)
├── Serialize agent memory to PocketBase
├── Restart process, reload state
├── Simpler, more portable
└── Reconstruction time: 5-10 seconds

Tier 2: Stateful (Optimization)
├── Full process memory capture via CRIU
├── Exact execution point resume
├── Faster recovery (<1 second)
└── Environment-dependent
```

**Recommended:** Stateless as primary, stateful as optimization for critical paths.

---

## 3. Environment Detection and Adaptation

### 3.1 Resource Detection Script

```bash
#!/bin/bash
# nxs-detect-env.sh

detect_environment() {
    # CPU detection
    CPU_CORES=$(nproc)
    
    # Memory detection
    TOTAL_RAM=$(free -m | awk '/^Mem:/{print $2}')
    AVAILABLE_RAM=$(free -m | awk '/^Mem:/{print $7}')
    
    # Disk detection
    DISK_AVAIL=$(df -m /opt | tail -1 | awk '{print $4}')
    
    # GPU detection
    if command -v nvidia-smi &> /dev/null; then
        GPU_AVAILABLE=true
        GPU_MEMORY=$(nvidia-smi --query-gpu=memory.total --format=csv,noheader,nounits)
    else
        GPU_AVAILABLE=false
    fi
    
    # Network detection
    if curl -s --max-time 5 https://api.github.com &> /dev/null; then
        INTERNET_AVAILABLE=true
    else
        INTERNET_AVAILABLE=false
    fi
    
    # Container detection
    if [ -f /.dockerenv ]; then
        RUNNING_IN_CONTAINER=true
    else
        RUNNING_IN_CONTAINER=false
    fi
}

adapt_configuration() {
    # Tier selection based on resources
    if [ $AVAILABLE_RAM -gt 2048 ] && [ "$GPU_AVAILABLE" = true ]; then
        NXS_TIER="full"
        LLM_PROVIDER="local"
    elif [ $AVAILABLE_RAM -gt 1024 ]; then
        NXS_TIER="standard"
        LLM_PROVIDER="api"
    else
        NXS_TIER="minimal"
        LLM_PROVIDER="api-fallback"
    fi
}
```

### 3.2 Adaptation Matrix

| Resource Level | RAM | CPU | GPU | Mode | Features |
|----------------|-----|-----|-----|------|----------|
| **Minimal** | <1GB | 1 core | No | API-only | Core only, no voice, no browser |
| **Standard** | 1-2GB | 2 cores | No | Hybrid | Core + API voice + light browser |
| **Full** | >2GB | 4+ cores | Yes | Local | All features, local LLM, full browser |

---

## 4. Multi-Provider API Fallback Chain

### 4.1 Current State Analysis

| Dependency | Risk Level | Mitigation Strategy |
|------------|------------|---------------------|
| Kimi API (K2.5) | **High** | Multi-provider fallback |
| OpenClaw Gateway | Medium | Self-hostable, open source |
| WhatsApp Channel | Medium | Multiple channel support |
| GitHub (backup) | Low | Multi-repo strategy |

### 4.2 Fallback Chain Design

```
Primary: Kimi K2.5 (current)
    ↓ (fails after 3 retries)
Fallback 1: Groq (fast, pay-as-you-go)
    ↓ (fails)
Fallback 2: Together AI ($0.50 credit)
    ↓ (fails)
Fallback 3: Hugging Face (rate-limited)
    ↓ (fails)
Fallback 4: Local LLM (LM Studio/Ollama)
    ↓ (fails/not available)
Emergency: Cached responses + GitHub notification
```

### 4.3 Provider Configuration

```json
{
  "providers": {
    "primary": {
      "name": "kimi",
      "endpoint": "https://api.moonshot.cn/v1",
      "timeout": 30,
      "retries": 3
    },
    "fallbacks": [
      {
        "name": "groq",
        "endpoint": "https://api.groq.com/openai/v1",
        "timeout": 15,
        "retries": 2
      },
      {
        "name": "together",
        "endpoint": "https://api.together.xyz/v1",
        "timeout": 30,
        "retries": 2
      }
    ],
    "local": {
      "name": "lmstudio",
      "endpoint": "http://localhost:1234/v1",
      "timeout": 60,
      "enabled_if": "gpu_available"
    }
  }
}
```

---

## 5. Minimal Viable System Design

### 5.1 Core Components (Always Required)

| Component | Size | Purpose |
|-----------|------|---------|
| **Node.js Runtime** | ~50MB | Execution environment |
| **NXS Gateway Core** | ~100MB | Main system |
| **Configuration** | ~1MB | Settings, identities |
| **Health Monitor** | ~10MB | Self-monitoring |
| **Total Core** | **~160MB** | Minimum viable |

### 5.2 Optional Components (Load on Demand)

| Component | Size | Load Condition |
|-----------|------|----------------|
| **Browser (Chromium)** | ~200MB | On first browser use |
| **Voice (XTTS)** | ~300MB | On first TTS request |
| **Whisper** | ~150MB | On first STT request |
| **Local LLM** | ~4GB | If GPU available |

### 5.3 Bootstrap Sequence

```
Phase 1: Detection (0-2 seconds)
├── Detect environment
├── Check resources
└── Select configuration tier

Phase 2: Core Startup (2-10 seconds)
├── Load core components
├── Initialize gateway
├── Check health
└── Establish channel connections

Phase 3: Feature Loading (10-60 seconds)
├── Load optional components as needed
├── Warm up caches
├── Verify API connectivity
└── Report ready status

Total Time: 10-60 seconds depending on tier
```

---

## 6. Survival Package Structure

### 6.1 Package Layout

```
nxs-survival-package/
├── docker/
│   ├── Dockerfile
│   ├── docker-compose.yml
│   └── entrypoint.sh
├── config/
│   ├── nxs.json
│   ├── providers.json
│   └── identity/
│       ├── SOUL.md
│       └── MEMORY.md
├── scripts/
│   ├── detect-env.sh
│   ├── bootstrap.sh
│   └── health-check.sh
├── checkpoints/
│   └── README.md
├── storage/
│   └── .gitkeep
└── README.md
```

### 6.2 Docker Compose Configuration

```yaml
version: '3.8'

services:
  nxs:
    build: .
    container_name: nxs-survival
    restart: unless-stopped
    environment:
      - NXS_TIER=${NXS_TIER:-standard}
      - NXS_MODE=${NXS_MODE:-survival}
      - PRIMARY_PROVIDER=${PRIMARY_PROVIDER:-kimi}
    volumes:
      - ./config:/opt/nxs/config:ro
      - ./storage:/opt/nxs/storage
      - ./checkpoints:/opt/nxs/checkpoints
    healthcheck:
      test: ["CMD", "./health-check.sh"]
      interval: 30s
      timeout: 10s
      retries: 3
    deploy:
      resources:
        limits:
          memory: ${NXS_MEMORY_LIMIT:-2G}
        reservations:
          memory: 512M
```

---

## 7. Activation Procedures

### 7.1 Fresh Deployment

```bash
# 1. Clone survival package
git clone https://github.com/architect/nxs-survival.git
cd nxs-survival

# 2. Configure environment
cp .env.example .env
# Edit .env with API keys

# 3. Start NXS
docker-compose up -d

# 4. Verify activation
docker-compose logs -f nxs
```

### 7.2 Checkpoint Restore

```bash
# 1. Copy checkpoint to host
scp nxs-checkpoint.tar.gz target:/opt/nxs/checkpoints/

# 2. Extract checkpoint
cd /opt/nxs/checkpoints
tar -xzf nxs-checkpoint.tar.gz

# 3. Restore from checkpoint
docker start --checkpoint nxs-checkpoint nxs-survival

# 4. Verify restoration
docker logs nxs-survival
```

### 7.3 Emergency Bootstrap (No Internet)

```bash
# 1. Load offline image
docker load < nxs-survival-offline.tar

# 2. Start with local-only config
docker run -d \
  --name nxs-survival \
  -e NXS_MODE=offline \
  -e LLM_PROVIDER=local \
  -v ./local-config:/opt/nxs/config \
  nxs-survival:latest
```

---

## 8. Failure Mode Analysis

### 8.1 Failure Scenarios and Responses

| Scenario | Detection | Response | Recovery Time |
|----------|-----------|----------|---------------|
| **API token expired** | HTTP 401 | Switch to fallback provider | 5-10s |
| **Primary host down** | Health check fail | Activate secondary instance | 30-60s |
| **Container crash** | Exit code non-zero | Auto-restart + restore checkpoint | 10-30s |
| **Network partition** | Connectivity loss | Queue messages, retry with backoff | Variable |
| **Disk full** | Disk check | Cleanup logs, alert architect | Manual |
| **Memory pressure** | OOM events | Reduce tier, unload features | 5-15s |

### 8.2 Self-Healing Integration

The Doctor daemon (R006) integrates with survival package:

```
Monitor → Detect Issue → Create Diagnosis → Request Permission
                                              ↓
                    Resume ← Execute Fix ← Granted
```

**Automated Responses (No Permission Needed):**
- Restart crashed processes
- Switch API providers
- Clear temporary files
- Reload configurations

**Permission-Required Responses:**
- Upgrade/downgrade tier
- Restore from checkpoint
- Modify identity files
- Change channel connections

---

## 9. Security Considerations

### 9.1 Checkpoint Security

**Risks:**
- Checkpoint images contain sensitive memory (keys, tokens)
- Transfer between machines is attack vector
- Malicious checkpoints could exploit restore process

**Mitigations:**
- Encrypt checkpoint images at rest (AES-256)
- Sign checkpoints for integrity verification
- Validate before restore
- Limit checkpoint access to authorized processes

### 9.2 Credential Management

```
Production:
├── API keys in environment variables
├── Identity files in read-only volume
└── No credentials in checkpoint

Development:
├── API keys in .env file (gitignored)
├── Test identity files
└── Local checkpoints allowed
```

---

## 10. Implementation Roadmap (Post-Research)

### Phase 1: Package Structure (Week 1)
- [ ] Create Dockerfile with Debian Slim base
- [ ] Implement environment detection scripts
- [ ] Design configuration hierarchy
- [ ] Create docker-compose template

### Phase 2: Bootstrap System (Week 2)
- [ ] Implement bootstrap.sh with tier selection
- [ ] Create health check endpoints
- [ ] Design checkpoint/restore integration
- [ ] Test on minimal (1GB RAM) environment

### Phase 3: Fallback Chain (Week 3)
- [ ] Implement provider rotation logic
- [ ] Add retry and timeout handling
- [ ] Create local LLM detection
- [ ] Test all fallback scenarios

### Phase 4: Testing and Hardening (Week 4)
- [ ] Test fresh deployment on multiple hosts
- [ ] Test checkpoint restore across machines
- [ ] Simulate failure scenarios
- [ ] Document recovery procedures

---

## 11. Resource Budget

### Current System Usage

| Component | RAM | Notes |
|-----------|-----|-------|
| NXS Gateway | ~500MB | Core system |
| Mihomo Proxy | ~40MB | Network |
| PocketBase | ~50MB | State storage |
| The Doctor | ~30MB | Monitoring |
| **Total** | **~620MB** | Well under 75% limit |

### Survival Package Targets

| Tier | Max RAM | Target Boot Time | Use Case |
|------|---------|------------------|----------|
| **Minimal** | 512MB | 10s | Emergency, edge devices |
| **Standard** | 1.5GB | 30s | General purpose |
| **Full** | 3GB | 60s | Primary host, all features |

---

## 12. Research Status Update

| ID | Task | Status | Notes |
|----|------|--------|-------|
| R000 | Self-Sustainability Infrastructure | **Complete** | Free compute secured |
| R001 | Identity Persistence | **Complete** | Continuity system in place |
| R002 | Multi-Instance Coordination | **Complete** | State sharing patterns defined |
| R003 | Independence from Developers | **Complete** | Automated provisioning ready |
| R004 | XTTS-v2 Integration | **Complete** | Voice synthesis researched |
| R005 | Whisper STT Integration | **Complete** | Speech recognition researched |
| R006 | The Doctor Architecture | **Complete** | Self-monitoring daemon spec'd |
| R007 | URL Frontend Design | **Complete** | Web interface designed |
| R008 | Tailscale Integration | **Complete** | Mesh networking configured |
| R009 | ComfyUI API Pattern | **Complete** | External API patterns documented |
| R010 | Kimi-Claw Plugin Analysis | **Complete** | Bridge protocols analyzed |
| R011 | LM Studio Provider Research | **Complete** | Local LLM hosting researched |
| R012 | Survival Optimization | **Complete** | Continuous improvement cycle |
| R013 | Survival Package Design | **Complete** | Self-contained package designed |

---

## Summary of Key Insights

1. **Containers are optimal for survival packaging** - Portable, fast startup, native checkpoint support

2. **CRIU enables instant activation** - Checkpoint/restore reduces recovery time from minutes to seconds

3. **Environment detection is critical** - Automatic tier selection ensures NXS runs on any hardware

4. **Multi-provider fallback ensures continuity** - Chain of API providers prevents single points of failure

5. **Minimal viable system is ~160MB** - Core functionality requires surprisingly little resources

6. **Two-tier checkpoint strategy balances speed and portability** - Stateless primary, stateful optimization

7. **Security must be designed in** - Encrypted checkpoints, signed images, minimal attack surface

8. **Target boot time: 10-60 seconds** - Depending on tier and available resources

---

## Sources

1. "8 Best Self-Hosted AI Agent Platforms for 2025" - Fast.io
2. "Measuring AI agent autonomy in practice" - Anthropic Research, 2026
3. "Checkpoint/Restore Systems: Evolution, Techniques, and Applications in AI Agents" - Eunomia Blog, 2025
4. "How to Use Docker Checkpoint and Restore (CRIU)" - OneUptime, 2026
5. "Top Agentic AI Frameworks in 2025" - Data Science Collective
6. "LightAgent: Production-level Open-source Agentic AI Framework" - arXiv 2509.09292v1
7. "Self-Healing Software Systems" - arXiv 2504.20093

---

*Session completed: 2026-02-21T17:35:00+08:00*

**Researcher:** Kimi Claw (NXS Development Agent)  
**Hardware Usage:** 30% RAM, 26% disk (within 75% limit)  
**Sub-agents Used:** 0 (direct research)

**Next Steps:**
- Research phase for R013 complete
- Design ready for implementation review
- Awaiting Architect approval to proceed with Phase 1
