# NXS Research Log

## Research Session: 2026-02-19

### Task 1: XTTS-v2 API Server Research

**Objective:** Research how to integrate XTTS-v2 as a built-in voice synthesis component

**Key Findings:**
- XTTS-v2 is by Coqui AI (now defunct, but open source)
- Can run as local API server
- Requires Python environment
- Model size: ~400MB-1GB depending on version
- Supports voice cloning with short samples

**Integration Approaches:**
1. **Docker container** - Isolate XTTS, expose API port
2. **Python virtualenv** - Run directly on host
3. **Download on demand** - Fetch model when first used

**Resource Requirements:**
- RAM: 2-4GB when running
- GPU optional (CPU works but slower)
- Disk: ~1GB for models

**API Endpoints Needed:**
- POST /tts - Text to speech
- GET /voices - List available voices
- POST /clone - Clone voice from sample

**Next Steps:**
- Research specific installation methods
- Compare Docker vs direct installation
- Document API integration pattern

---

### Task 2: Whisper STT Research

**Objective:** Research Whisper integration for speech-to-text

**Key Findings:**
- OpenAI Whisper (open source)
- Multiple model sizes: tiny, base, small, medium, large
- tiny = 39MB, base = 74MB, small = 244MB
- Can run as API server or library

**Recommended Model:**
- **base** or **small** for NXS
- Good balance of accuracy vs resource usage
- English recognition sufficient for most use cases

**Integration Options:**
1. **faster-whisper** - Optimized version, faster on CPU
2. **whisper.cpp** - C++ implementation, very lightweight
3. **OpenAI whisper** - Original Python version

**API Pattern:**
- POST /transcribe - Audio file → text
- Supports multiple formats (wav, mp3, ogg)

**Resource Usage:**
- RAM: 500MB-1GB depending on model
- CPU intensive during transcription
- Can run on CPU (no GPU required)

---

### Task 3: The Doctor Architecture

**Objective:** Design the system maintenance daemon

**Architecture Decision:**
- **Language:** Go (like PicoClaw) or Python
- **Communication:** Unix socket or HTTP API
- **Trigger:** Permission-based from NXS agents

**Components:**
1. **Monitor** - Continuous resource tracking
2. **Diagnoser** - Analyze issues, create reports
3. **Actor** - Execute fixes (when permitted)
4. **Logger** - Record all activities

**Monitoring Targets:**
- RAM usage (alert at 70%)
- Disk usage (alert at 75%)
- Zombie processes
- Browser binary health
- Proxy connectivity
- Extension status

**Communication Protocol:**
```
Doctor → NXS: DIAGNOSIS {issue, severity, suggested_action}
NXS → Doctor: PERMIT {action_id} or DENY
Doctor → NXS: RESULT {success/failure, details}
```

**Safety Mechanisms:**
- Never act without permission
- Rollback capability for changes
- Dry-run mode for testing
- Resource limits on doctor itself

---

### Task 4: URL Frontend Architecture

**Objective:** Design web interface to replace chat channels

**Technology Options:**

| Option | Pros | Cons |
|--------|------|------|
| **React + Vite** | Modern, fast | Build complexity |
| **Vue 3** | Simple, lightweight | Smaller ecosystem |
| **Plain HTML/JS** | Zero dependencies | Manual DOM management |
| **Svelte** | Compiled, small | Learning curve |

**Recommended:** Vue 3 or Plain HTML/JS for simplicity

**Features Needed:**
- Chat interface (messages, input)
- Voice recording/playback
- File upload/download
- Settings panel
- Connection status indicator

**API Communication:**
- WebSocket for real-time messages
- HTTP REST for file operations
- SSE for status updates
- **See also: R007 Kimi-Claw Plugin Analysis for bridge protocol details**

**Tailscale Integration:**
- Auto-generate Tailscale auth key
- Expose frontend on Tailscale IP
- HTTPS via Tailscale certificates

---

### Task 5: Tailscale Integration Research

**Objective:** Research remote access via Tailscale

**Key Findings:**
- Free for personal use (up to 20 devices)
- MagicDNS for easy hostnames
- Automatic NAT traversal
- Built-in HTTPS certificates

**Setup Process:**
1. Install tailscale package
2. Authenticate with tailscale up
3. Get auth key for headless setup
4. Configure as subnet router (optional)

**NXS Integration:**
- Expose URL frontend on 0.0.0.0:PORT
- Access via https://nxs-device.tailnet-name.ts.net
- No port forwarding needed

**Security:**
- ACLs control who can access
- Device approval required
- Audit logs available

---

## Research Tasks Queue

### High Priority
- [ ] Detailed XTTS installation methods
- [ ] Whisper API server setup
- [ ] Doctor daemon specification

### Medium Priority
- [ ] URL frontend framework comparison
- [ ] Tailscale automation scripts
- [ ] ComfyUI API integration patterns

### Low Priority
- [ ] Browser optimization strategies
- [ ] Extension lazy-loading mechanisms
- [ ] Voice message flow design

---

## Resources Found

### Documentation
- XTTS: https://github.com/coqui-ai/TTS
- Whisper: https://github.com/openai/whisper
- Tailscale: https://tailscale.com/kb/
- PicoClaw: /opt/development/PicoClaw-REFERENCE-DO-NOT-CLEAN/

### Reference Implementations
- OpenClaw: /opt/development/OpenClaw-2.13-REFERENCE-DO-NOT-CLEAN/
- Browser automation: ~/.openclaw/skills/browser-automation/

---

## Git Repository Push: browser-automation Skill

**Repository:** https://github.com/Vox-Cardinal/NXS-DEGRID

**Files Pushed:**
- `skills/browser-automation/SKILL.md` - Comprehensive documentation
- `skills/browser-automation/VERSION` - Version 1.0.0
- `skills/browser-automation/package.json` - NPM manifest
- `skills/browser-automation/tsconfig.json` - TypeScript config
- `skills/browser-automation/setup.sh` - Setup script
- `skills/browser-automation/src/index.ts` - Main source code
- `skills/browser-automation/scripts/install-browser.sh` - Browser installer
- `skills/browser-automation/scripts/optimize-chromium.sh` - Optimization script

**Key Features Documented:**
- Native OpenClaw integration
- Automatic proxy usage
- Fetch, screenshot, PDF generation
- Interactive browser sessions
- Health monitoring

**Status:** Successfully pushed and verified via web browser

---

## Proxy Setup: Mihomo (Clash Verge Rev)

**Repository:** https://github.com/Vox-Cardinal/NXS-DEGRID

**What Was Set Up:**
- Clash Verge Rev v2.4.5 installed via DEB package
- Mihomo proxy running as systemd service
- Shadowsocks subscription converted to Clash format
- HTTP/SOCKS5 proxy on `127.0.0.1:7890`
- REST API on `127.0.0.1:9090`

**Files Created:**
- `/etc/systemd/system/mihomo.service` - Auto-start service
- `/root/.config/clash-verge/config.yaml` - Proxy configuration

**Key Features:**
- 80+ proxy nodes from subscription
- Auto-restart on failure
- Health monitoring via cron jobs
- System-wide proxy integration

**Status:** Running and stable

---

### Task 7: Kimi-Claw Plugin Analysis

**Objective:** Reverse-engineer the bridge protocol for NXS frontend (supports R004)

**Related Task:** R004 URL Frontend Design - this analysis provides the connection protocol

**Key Areas to Research:**
- Bridge protocol (ACP - Agent Communication Protocol)
- WebSocket connection handling
- Message format between frontend and gateway
- Authentication flow
- Session management

**Files to Analyze:**
- `/root/.openclaw/extensions/kimi-claw/` - Plugin source
- Gateway protocol documentation
- Bridge connection configuration

**Status:** Not started - pending R000 foundation research

---

*Session ended: Ready for next research task*
