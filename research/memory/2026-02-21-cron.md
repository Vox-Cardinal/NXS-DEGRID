# NXS Research Log

## Research Session: 2026-02-21 (Cron Auto-Run)

### Task R007: URL Frontend Design - COMPLETED

**Timestamp Coverage Achieved:** 2026-02-21T02:35:00+08:00

---

## R007 Final Findings: URL Frontend Architecture

### Overview
The URL Frontend provides a web-based interface for NXS, replacing heavy built-in chat channels with a lightweight browser-based UI. Combined with Tailscale for secure remote access, this creates a flexible, resource-efficient interaction model.

### Core Design Principles

| Principle | Implementation |
|-----------|----------------|
| **Lightweight** | Minimal JavaScript, no heavy frameworks |
| **Real-time** | WebSocket for bidirectional communication |
| **Voice-capable** | MediaRecorder API for audio input/output |
| **Secure** | Tailscale HTTPS + identity headers |
| **Local-first** | Works on localhost, extends via Tailscale |

### Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     USER DEVICES                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚   Phone     â”‚  â”‚   Laptop    â”‚  â”‚   Desktop   â”‚         â”‚
â”‚  â”‚  (Tailscale)â”‚  â”‚  (Tailscale)â”‚  â”‚  (Localhost)â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                â”‚                â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚ HTTPS / HTTP
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     TAILSCALE                               â”‚
â”‚              (WireGuard Mesh VPN)                           â”‚
â”‚         Automatic DNS + TLS Certificates                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     NXS HOST                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚              URL FRONTEND                        â”‚         â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚         â”‚
â”‚  â”‚  â”‚ Static HTML â”‚  â”‚ WebSocket  â”‚  â”‚ Voice    â”‚ â”‚         â”‚
â”‚  â”‚  â”‚   + CSS     â”‚  â”‚  Server    â”‚  â”‚ Handler  â”‚ â”‚         â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                          â”‚                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚              NXS CORE                            â”‚         â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚         â”‚
â”‚  â”‚  â”‚   Gateway   â”‚  â”‚  Skills    â”‚  â”‚  Doctor  â”‚ â”‚         â”‚
â”‚  â”‚  â”‚             â”‚  â”‚            â”‚  â”‚  (API)   â”‚ â”‚         â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Technology Stack Comparison

| Component | Option A | Option B | Option C | Recommendation |
|-----------|----------|----------|----------|----------------|
| **Frontend** | Vue 3 (~30KB) | Alpine.js (~15KB) | Plain HTML/JS | **Alpine.js** - sweet spot |
| **Real-time** | WebSocket | SSE | Long-polling | **WebSocket** - bidirectional |
| **Voice Input** | MediaRecorder | WebRTC | External | **MediaRecorder** - native |
| **Remote Access** | Tailscale | WireGuard | ngrok | **Tailscale** - zero config |
| **Auth** | Tailscale headers | JWT | None | **Tailscale headers** - seamless |

### Frontend Framework Decision: Alpine.js

**Why Alpine.js over Vue 3 or Plain JS:**

| Factor | Alpine.js | Vue 3 | Plain JS |
|--------|-----------|-------|----------|
| Size | ~15KB | ~30KB | 0KB |
| Learning curve | Low | Medium | None |
| Reactivity | Built-in | Built-in | Manual |
| Template syntax | HTML directives | Template/JSX | N/A |
| State management | Simple | Vuex/Pinia | Manual |
| **Verdict** | **âœ“ Best balance** | Overkill | Too verbose |

**Alpine.js Example - Chat Interface:**
```html
<!DOCTYPE html>
<html>
<head>
  <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
  <style>
    .chat-container { max-width: 800px; margin: 0 auto; }
    .message { padding: 10px; margin: 5px; border-radius: 8px; }
    .user { background: #e3f2fd; text-align: right; }
    .assistant { background: #f5f5f5; }
    .voice-btn { 
      width: 50px; height: 50px; border-radius: 50%; 
      background: #2196f3; color: white; border: none;
      cursor: pointer;
    }
    .voice-btn.recording { background: #f44336; animation: pulse 1s infinite; }
    @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); } }
  </style>
</head>
<body>
  <div class="chat-container" x-data="chatApp()">
    <div id="messages">
      <template x-for="msg in messages" :key="msg.id">
        <div :class="'message ' + msg.role" x-text="msg.content"></div>
      </template>
    </div>
    
    <div class="input-area">
      <input type="text" x-model="inputText" @keyup.enter="sendMessage()">
      <button @click="sendMessage()">Send</button>
      <button class="voice-btn" 
              :class="{ 'recording': isRecording }"
              @mousedown="startRecording()"
              @mouseup="stopRecording()">
        ğŸ¤
      </button>
    </div>
  </div>

  <script>
    function chatApp() {
      return {
        messages: [],
        inputText: '',
        isRecording: false,
        ws: null,
        mediaRecorder: null,
        
        init() {
          this.connectWebSocket();
        },
        
        connectWebSocket() {
          const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
          this.ws = new WebSocket(`${protocol}//${window.location.host}/ws`);
          
          this.ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            this.messages.push(data);
          };
        },
        
        sendMessage() {
          if (!this.inputText.trim()) return;
          this.ws.send(JSON.stringify({
            type: 'message',
            content: this.inputText
          }));
          this.inputText = '';
        },
        
        async startRecording() {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          this.mediaRecorder = new MediaRecorder(stream);
          this.audioChunks = [];
          
          this.mediaRecorder.ondataavailable = (e) => {
            this.audioChunks.push(e.data);
          };
          
          this.mediaRecorder.onstop = () => {
            const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });
            this.sendVoiceMessage(audioBlob);
          };
          
          this.mediaRecorder.start();
          this.isRecording = true;
        },
        
        stopRecording() {
          this.mediaRecorder.stop();
          this.isRecording = false;
          this.mediaRecorder.stream.getTracks().forEach(t => t.stop());
        },
        
        sendVoiceMessage(blob) {
          const reader = new FileReader();
          reader.onloadend = () => {
            this.ws.send(JSON.stringify({
              type: 'voice',
              audio: reader.result.split(',')[1]  // base64
            }));
          };
          reader.readAsDataURL(blob);
        }
      }
    }
  </script>
</body>
</html>
```

### Real-time Communication: WebSocket vs SSE

**Decision: WebSocket for NXS Frontend**

| Aspect | WebSocket | Server-Sent Events |
|--------|-----------|-------------------|
| Direction | Bidirectional | Serverâ†’Client only |
| Protocol | ws/wss | HTTP |
| Reconnection | Manual handling | Automatic |
| Binary data | Native | Base64 encoded |
| Browser support | Excellent | Good |
| **Use for NXS** | **âœ“ Yes** | Status updates only |

**WebSocket Message Protocol:**
```json
// Client â†’ Server
{
  "type": "message",
  "content": "Hello NXS",
  "timestamp": "2026-02-21T02:30:00Z"
}

{
  "type": "voice",
  "audio": "base64encoded...",
  "format": "webm"
}

{
  "type": "command",
  "action": "get_status"
}

// Server â†’ Client
{
  "type": "response",
  "content": "Hello! How can I help?",
  "role": "assistant",
  "timestamp": "2026-02-21T02:30:01Z"
}

{
  "type": "voice_response",
  "audio_url": "/audio/response-123.mp3",
  "duration": 3.5
}

{
  "type": "status",
  "cpu": 15,
  "memory": 45,
  "uptime": 86400
}
```

### Voice Integration with MediaRecorder API

**Browser Support:** Excellent (Chrome, Firefox, Safari, Edge since 2021)

**Implementation Pattern:**
```javascript
// Voice recording flow
async function recordVoice() {
  // 1. Get microphone access
  const stream = await navigator.mediaDevices.getUserMedia({ 
    audio: {
      echoCancellation: true,
      noiseSuppression: true,
      sampleRate: 16000  // Whisper optimized
    }
  });
  
  // 2. Create recorder
  const recorder = new MediaRecorder(stream, {
    mimeType: 'audio/webm;codecs=opus'  // Compact format
  });
  
  // 3. Collect data
  const chunks = [];
  recorder.ondataavailable = (e) => chunks.push(e.data);
  
  // 4. On stop, send to server
  recorder.onstop = () => {
    const blob = new Blob(chunks, { type: 'audio/webm' });
    sendToWhisper(blob);  // Server-side STT
  };
  
  recorder.start();
  return recorder;
}
```

**Audio Pipeline:**
```
Browser (MediaRecorder)
    â†“ webm/opus
WebSocket
    â†“
NXS Gateway
    â†“
Whisper STT (faster-whisper)
    â†“
NXS Processing
    â†“
XTTS-v2 (if voice response)
    â†“
Browser (HTMLAudioElement)
```

### Tailscale Integration

**Local Development:**
```bash
# Serve NXS frontend locally
tailscale serve --https=443 localhost:8080

# Results in: https://nxs-host.tailnet-name.ts.net
```

**Key Features for NXS:**

| Feature | Benefit |
|---------|---------|
| **MagicDNS** | Access via `https://nxs-host.tailnet.ts.net` |
| **Auto HTTPS** | TLS certificates provisioned automatically |
| **Identity Headers** | `Tailscale-User-Login` for auth |
| **ACLs** | Control who can access NXS |
| **Funnel** | Optional public exposure |

**Authentication via Tailscale Headers:**
```python
# NXS backend reads identity from headers
user_email = request.headers.get('Tailscale-User-Login')
user_name = request.headers.get('Tailscale-User-Name')

if user_email:
    # User is authenticated via Tailscale
    session.user = user_email
else:
    # Local access - no auth required
    session.user = 'local'
```

**Security Model:**
```
Localhost Access: No auth (assumed safe)
Tailscale Access: Identity headers (Tailscale auth)
Funnel Access: Not recommended for NXS (or require additional auth)
```

### API Endpoints

**HTTP REST API:**
| Endpoint | Method | Purpose |
|----------|--------|---------|
| `/` | GET | Serve frontend HTML |
| `/api/status` | GET | System status |
| `/api/messages` | GET | Message history |
| `/api/voice` | POST | Upload voice message |
| `/api/audio/:id` | GET | Download TTS audio |

**WebSocket Endpoint:**
| Endpoint | Purpose |
|----------|---------|
| `/ws` | Real-time bidirectional communication |

**Doctor Integration:**
| Endpoint | Purpose |
|----------|---------|
| `/doctor` | POST - Receive diagnosis from Doctor |
| `/doctor/permission` | POST - Send permission to Doctor |

### Resource Requirements

| Component | RAM | Disk | Notes |
|-----------|-----|------|-------|
| Static files | 0MB | ~100KB | HTML/CSS/JS |
| WebSocket server | ~10MB | 0MB | Per connection |
| Voice handling | ~20MB | 0MB | Temporary buffers |
| **Total frontend** | **~30MB** | **~100KB** | Very lightweight |

### Comparison: URL Frontend vs Built-in Channels

| Aspect | URL Frontend | Built-in Channels |
|--------|--------------|-------------------|
| **Size** | ~100KB | ~50MB+ (Telegram, Discord libs) |
| **Dependencies** | Browser only | Node modules, API tokens |
| **Setup** | Open browser | Configure APIs, tokens |
| **Remote access** | Tailscale | Internet + provider APIs |
| **Offline** | Tailscale LAN works | Depends on provider |
| **Voice** | Native Web API | Provider-dependent |
| **Customization** | Full control | Limited by provider |
| **Mobile** | Responsive web | Native apps |

### Implementation Roadmap

**Phase 1: Core Frontend (Week 1)**
- [ ] Static HTML/CSS/JS files
- [ ] WebSocket server integration
- [ ] Basic chat interface
- [ ] Message history

**Phase 2: Voice Integration (Week 2)**
- [ ] MediaRecorder implementation
- [ ] Whisper STT integration
- [ ] XTTS-v2 playback
- [ ] Voice message UI

**Phase 3: Tailscale Polish (Week 3)**
- [ ] HTTPS configuration
- [ ] Identity header auth
- [ ] ACL documentation
- [ ] Mobile responsiveness

**Phase 4: Doctor Integration (Week 4)**
- [ ] Doctor diagnosis display
- [ ] Permission UI
- [ ] System status dashboard
- [ ] Log viewer

### File Structure

```
/opt/development/nxs-frontend/
â”œâ”€â”€ index.html          # Main UI
â”œâ”€â”€ css/
â”‚   â””â”€â”€ styles.css      # Alpine.js-compatible styles
â”œâ”€â”€ js/
â”‚   â”œâ”€â”€ app.js          # Main Alpine.js app
â”‚   â”œâ”€â”€ websocket.js    # WebSocket client
â”‚   â””â”€â”€ voice.js        # MediaRecorder wrapper
â”œâ”€â”€ assets/
â”‚   â””â”€â”€ favicon.ico
â””â”€â”€ README.md
```

### Next Steps

1. **Prototype core UI** - Single HTML file with Alpine.js
2. **WebSocket integration** - Connect to NXS gateway
3. **Voice testing** - Test MediaRecorder across browsers
4. **Tailscale setup** - Configure HTTPS and test remote access

---

## Research Status Update

| ID | Task | Status | Notes |
|----|------|--------|-------|
| R000 | Self-Sustainability Infrastructure | **Complete** | Free compute, token independence plan |
| R001 | Identity Persistence | **Complete** | XTTS-v2 integration documented |
| R002 | Multi-Instance Coordination | **Complete** | Whisper STT + speaches documented |
| R003 | Independence from Developers | **Complete** | The Doctor architecture defined |
| R004 | XTTS-v2 Integration | **Complete** | Docker + pip options documented |
| R005 | Whisper STT Integration | **Complete** | faster-whisper + speaches identified |
| R006 | The Doctor Architecture | **Complete** | Full specification documented |
| R007 | URL Frontend Design | **Complete** | Alpine.js + WebSocket + Tailscale |
| R008 | Tailscale Integration | Planned | Deep dive into mesh networking |
| R009 | ComfyUI API Pattern | Planned | External service integration |
| R010 | Kimi-Claw Plugin Analysis | Planned | Bridge protocols |
| R011 | LM Studio Provider Research | Planned | Local model hosting |

---

## Next Research Priority

**R008: Tailscale Integration** - Deep dive into mesh networking, ACLs, and multi-instance coordination via Tailscale.

*Research scheduled for next cron run.*

---

*Session ended: 2026-02-21T02:40:00+08:00*
