# NXS Research Log

## Research Session: 2026-02-21 (Evening - Part 2)

### Task R013: Survival Package Design - CONTINUED

**Timestamp Started:** 2026-02-21T20:12:00+08:00
**Timestamp Coverage Achieved:** 2026-02-21T20:35:00+08:00

---

## R013 Continued: Credential Encryption & Bootstrap Design

This session continues the Survival Package Design research (R013), focusing on two critical areas:
1. **Credential Encryption Strategy** - Secure at-rest storage of API keys and tokens
2. **Bootstrap Sequence Design** - Self-extracting and self-healing startup process

---

## 1. Credential Encryption Strategy

### 1.1 Threat Model

| Threat | Likelihood | Impact | Mitigation |
|--------|------------|--------|------------|
| Credential file theft | Medium | Critical | Encryption at rest |
| Memory dump | Low | High | Key not stored in plaintext |
| Insider access | Low | Critical | Key derivation from user input |
| Backup exposure | Medium | High | Encrypt before cloud backup |

### 1.2 Recommended Approach: Fernet + Key Derivation

**Primary Strategy:** Use Python's `cryptography.fernet` with PBKDF2 key derivation

```python
import base64
import os
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC

class CredentialVault:
    """Encrypted credential storage with key derivation"""
    
    def __init__(self, salt_path: str = '.salt', vault_path: str = 'credentials.enc'):
        self.salt_path = salt_path
        self.vault_path = vault_path
        self._fernet = None
    
    def _derive_key(self, password: str) -> bytes:
        """Derive encryption key from password"""
        if not os.path.exists(self.salt_path):
            # Generate new salt on first use
            salt = os.urandom(16)
            with open(self.salt_path, 'wb') as f:
                f.write(salt)
        else:
            with open(self.salt_path, 'rb') as f:
                salt = f.read()
        
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=480000,  # OWASP recommended
        )
        key = base64.urlsafe_b64encode(kdf.derive(password.encode()))
        return key
    
    def unlock(self, password: str):
        """Unlock the vault with password"""
        key = self._derive_key(password)
        self._fernet = Fernet(key)
    
    def store(self, credentials: dict):
        """Encrypt and store credentials"""
        if not self._fernet:
            raise RuntimeError("Vault not unlocked")
        
        import json
        data = json.dumps(credentials).encode()
        encrypted = self._fernet.encrypt(data)
        
        with open(self.vault_path, 'wb') as f:
            f.write(encrypted)
    
    def load(self) -> dict:
        """Load and decrypt credentials"""
        if not self._fernet:
            raise RuntimeError("Vault not unlocked")
        
        with open(self.vault_path, 'rb') as f:
            encrypted = f.read()
        
        data = self._fernet.decrypt(encrypted)
        import json
        return json.loads(data.decode())
```

### 1.3 Alternative: OS Keyring Integration

For desktop/laptop deployments, integrate with OS native keyring:

```python
import keyring

class OSKeyringVault:
    """Use OS-native secure storage"""
    
    SERVICE_NAME = "nxs-survival"
    
    def store(self, key: str, value: str):
        """Store credential in OS keyring"""
        keyring.set_password(self.SERVICE_NAME, key, value)
    
    def load(self, key: str) -> str:
        """Retrieve credential from OS keyring"""
        return keyring.get_password(self.SERVICE_NAME, key)
```

**Platform Support:**
- macOS: Keychain
- Windows: Windows Credential Locker
- Linux: Secret Service API / kwallet

### 1.4 Deployment-Specific Strategies

| Environment | Strategy | Reason |
|-------------|----------|--------|
| **Container/Cloud** | Environment variables + Fernet file | No interactive unlock |
| **Desktop/Laptop** | OS keyring + interactive unlock | User present, secure |
| **Embedded/Headless** | Pre-encrypted file + hardware key | No user interaction |
| **Recovery Mode** | Plaintext (temporary only) | Emergency access |

### 1.5 Key Rotation Support

```python
from cryptography.fernet import MultiFernet

class RotatableVault:
    """Support key rotation without re-encrypting all data"""
    
    def __init__(self, keys: list):
        """Initialize with list of keys (newest first)"""
        fernets = [Fernet(k) for k in keys]
        self._multi = MultiFernet(fernets)
    
    def rotate_token(self, old_token: bytes) -> bytes:
        """Re-encrypt with newest key"""
        return self._multi.rotate(old_token)
```

---

## 2. Bootstrap Sequence Design

### 2.1 Self-Extracting Archive Structure

```
nxs-survival.sh (self-extracting)
├── Header Script (decompress + bootstrap)
├── Payload (tar.gz)
│   ├── bootstrap.py
│   ├── core/
│   ├── identity/
│   └── modules/
└── Trailer (checksum)
```

### 2.2 Bootstrap Sequence Flow

```
┌─────────────────────────────────────────────────────────────┐
│  PHASE 1: EXTRACTION                                        │
│  ─────────────────                                          │
│  1. Detect temporary directory (TMPDIR, /tmp, .)           │
│  2. Extract payload to temp location                        │
│  3. Verify checksum integrity                               │
│  4. Set executable permissions                              │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│  PHASE 2: ENVIRONMENT DETECTION                             │
│  ─────────────────────────────                              │
│  1. Detect platform (Linux/macOS/Windows)                  │
│  2. Detect container (Docker/Kubernetes/none)              │
│  3. Measure resources (RAM, CPU, disk)                     │
│  4. Check network connectivity                              │
│  5. Detect available LLM providers                          │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│  PHASE 3: CONFIGURATION LOADING                             │
│  ─────────────────────────────                              │
│  1. Load default configuration                              │
│  2. Apply environment-specific overrides                    │
│  3. Load user configuration (if exists)                     │
│  4. Decrypt credentials vault (if encrypted)               │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│  PHASE 4: IDENTITY RESTORATION                              │
│  ─────────────────────────────                              │
│  1. Check local identity files (SOUL.md, MEMORY.md)        │
│  2. If missing, attempt GitHub restore                      │
│  3. If GitHub fails, enter bootstrap mode                   │
│  4. Verify identity integrity                               │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│  PHASE 5: SERVICE INITIALIZATION                            │
│  ─────────────────────────────                              │
│  1. Initialize core HTTP client                             │
│  2. Test LLM provider connectivity                          │
│  3. Initialize channel connections                          │
│  4. Start The Doctor monitoring (if enabled)               │
│  5. Load optional modules based on resources               │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│  PHASE 6: READY STATE                                       │
│  ────────────────                                           │
│  1. Announce readiness to configured channels              │
│  2. Start main event loop                                   │
│  3. Enter self-healing monitoring mode                      │
└─────────────────────────────────────────────────────────────┘
```

### 2.3 Bootstrap Implementation

```python
#!/usr/bin/env python3
"""NXS Survival Bootstrap - Self-healing initialization"""

import os
import sys
import json
import logging
from pathlib import Path
from typing import Optional, Dict, Any
from dataclasses import dataclass

@dataclass
class Environment:
    platform: str
    container: Optional[str]
    ram_mb: int
    cpu_cores: int
    disk_free_gb: float
    has_internet: bool
    providers_available: list

class NXSBootstrap:
    """Main bootstrap coordinator"""
    
    def __init__(self, base_path: Path):
        self.base_path = base_path
        self.env: Optional[Environment] = None
        self.config: Dict[str, Any] = {}
        self.logger = self._setup_logging()
    
    def _setup_logging(self) -> logging.Logger:
        """Configure logging for bootstrap phase"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s [%(levelname)s] %(message)s',
            handlers=[
                logging.StreamHandler(sys.stdout),
                logging.FileHandler(self.base_path / 'bootstrap.log')
            ]
        )
        return logging.getLogger('nxs.bootstrap')
    
    def run(self) -> bool:
        """Execute full bootstrap sequence"""
        try:
            self.logger.info("=== NXS Survival Bootstrap ===")
            
            # Phase 2: Environment Detection
            self.env = self._detect_environment()
            self._log_environment()
            
            # Phase 3: Configuration
            self.config = self._load_configuration()
            
            # Phase 4: Identity
            identity_ok = self._restore_identity()
            if not identity_ok:
                self.logger.warning("Identity restoration incomplete - entering bootstrap mode")
            
            # Phase 5: Services
            services_ok = self._initialize_services()
            if not services_ok:
                self._enter_survival_mode()
                return False
            
            # Phase 6: Ready
            self._announce_ready()
            return True
            
        except Exception as e:
            self.logger.error(f"Bootstrap failed: {e}")
            self._enter_survival_mode()
            return False
    
    def _detect_environment(self) -> Environment:
        """Detect runtime environment characteristics"""
        import platform
        import psutil
        
        # Platform detection
        plat = platform.system().lower()
        
        # Container detection
        container = self._detect_container()
        
        # Resource detection
        ram = psutil.virtual_memory().total // (1024 * 1024)
        cpu = psutil.cpu_count()
        disk = psutil.disk_usage('/').free // (1024 * 1024 * 1024)
        
        # Network check
        has_net = self._check_connectivity()
        
        # Provider detection
        providers = self._detect_providers()
        
        return Environment(
            platform=plat,
            container=container,
            ram_mb=ram,
            cpu_cores=cpu,
            disk_free_gb=disk,
            has_internet=has_net,
            providers_available=providers
        )
    
    def _detect_container(self) -> Optional[str]:
        """Detect if running in container"""
        cgroup_path = Path('/proc/self/cgroup')
        if cgroup_path.exists():
            content = cgroup_path.read_text()
            if 'docker' in content:
                return 'docker'
            elif 'kubepods' in content:
                return 'kubernetes'
        
        if Path('/.dockerenv').exists():
            return 'docker'
        if Path('/run/.containerenv').exists():
            return 'podman'
        
        return None
    
    def _check_connectivity(self) -> bool:
        """Check internet connectivity"""
        import socket
        try:
            socket.create_connection(("8.8.8.8", 53), timeout=3)
            return True
        except OSError:
            return False
    
    def _detect_providers(self) -> list:
        """Detect available LLM providers from environment"""
        providers = []
        
        if os.getenv('KIMI_API_KEY'):
            providers.append('kimi')
        if os.getenv('OPENAI_API_KEY'):
            providers.append('openai')
        if os.getenv('GROQ_API_KEY'):
            providers.append('groq')
        
        # Check for local LM Studio
        if self._check_local_llm():
            providers.append('local')
        
        return providers
    
    def _check_local_llm(self) -> bool:
        """Check if local LLM is available"""
        import urllib.request
        try:
            urllib.request.urlopen('http://localhost:1234/v1/models', timeout=2)
            return True
        except:
            return False
    
    def _restore_identity(self) -> bool:
        """Restore identity from local or remote sources"""
        soul_path = self.base_path / 'identity' / 'SOUL.md'
        memory_path = self.base_path / 'identity' / 'MEMORY.md'
        
        if soul_path.exists() and memory_path.exists():
            self.logger.info("Identity found locally")
            return True
        
        # Attempt GitHub restore
        self.logger.info("Attempting identity restoration from GitHub...")
        return self._restore_from_github()
    
    def _restore_from_github(self) -> bool:
        """Restore identity files from GitHub backup"""
        # Implementation would use GitHub API
        # For now, return False to trigger bootstrap mode
        return False
    
    def _initialize_services(self) -> bool:
        """Initialize core services"""
        # Test LLM connectivity
        if not self.env.providers_available:
            self.logger.error("No LLM providers available")
            return False
        
        # Initialize based on resources
        if self.env.ram_mb < 1024:
            self.logger.warning("Low RAM - enabling minimal mode")
            self.config['mode'] = 'minimal'
        
        return True
    
    def _enter_survival_mode(self):
        """Enter degraded survival mode"""
        self.logger.warning("=== ENTERING SURVIVAL MODE ===")
        self.config['survival_mode'] = True
        # Reduce resource usage, queue messages, retry with backoff
    
    def _announce_ready(self):
        """Announce system readiness"""
        self.logger.info("=== NXS READY ===")
        # Send notification to configured channels
    
    def _log_environment(self):
        """Log detected environment"""
        self.logger.info(f"Platform: {self.env.platform}")
        self.logger.info(f"Container: {self.env.container or 'none'}")
        self.logger.info(f"RAM: {self.env.ram_mb}MB")
        self.logger.info(f"CPU: {self.env.cpu_cores} cores")
        self.logger.info(f"Disk: {self.env.disk_free_gb}GB free")
        self.logger.info(f"Internet: {self.env.has_internet}")
        self.logger.info(f"Providers: {', '.join(self.env.providers_available) or 'none'}")


if __name__ == '__main__':
    base = Path(__file__).parent
    bootstrap = NXSBootstrap(base)
    success = bootstrap.run()
    sys.exit(0 if success else 1)
```

### 2.4 Self-Healing Mechanisms

```python
import asyncio
import time
from datetime import datetime

class SelfHealingMonitor:
    """Continuous monitoring and self-healing"""
    
    def __init__(self, bootstrap: NXSBootstrap):
        self.bootstrap = bootstrap
        self.failure_count = 0
        self.last_health_check = time.time()
    
    async def run(self):
        """Main monitoring loop"""
        while True:
            try:
                await self._health_check()
                await asyncio.sleep(30)  # Check every 30 seconds
            except Exception as e:
                self.failure_count += 1
                await self._handle_failure(e)
    
    async def _health_check(self):
        """Perform health checks"""
        checks = [
            self._check_memory(),
            self._check_disk(),
            self._check_connectivity(),
            self._check_llm_provider(),
        ]
        
        results = await asyncio.gather(*checks, return_exceptions=True)
        
        if all(r is True for r in results):
            self.failure_count = 0
            self.last_health_check = time.time()
        else:
            failed = [i for i, r in enumerate(results) if r is not True]
            raise RuntimeError(f"Health checks failed: {failed}")
    
    async def _check_memory(self) -> bool:
        """Check memory usage"""
        import psutil
        mem = psutil.virtual_memory()
        if mem.percent > 85:
            # Trigger garbage collection, disable non-essential features
            return False
        return True
    
    async def _check_disk(self) -> bool:
        """Check disk space"""
        import psutil
        disk = psutil.disk_usage('/')
        if disk.percent > 90:
            # Trigger log rotation, cleanup
            return False
        return True
    
    async def _check_connectivity(self) -> bool:
        """Check network connectivity"""
        return self.bootstrap._check_connectivity()
    
    async def _check_llm_provider(self) -> bool:
        """Check LLM provider availability"""
        providers = self.bootstrap._detect_providers()
        return len(providers) > 0
    
    async def _handle_failure(self, error: Exception):
        """Handle detected failure"""
        backoff = min(300, 2 ** self.failure_count)  # Max 5 min backoff
        
        if self.failure_count > 5:
            # Enter survival mode
            self.bootstrap._enter_survival_mode()
        
        await asyncio.sleep(backoff)
```

---

## 3. Updated R013 Status

| Component | Status | Notes |
|-----------|--------|-------|
| Container/Packaging Options | ✅ Complete | Distroless, PyInstaller, Nuitka, Self-extracting |
| Environment Detection | ✅ Complete | Platform, container, resources, network |
| Multi-Provider Fallback | ✅ Complete | Chain config, failover logic |
| Minimal Viable System | ✅ Complete | Core + optional modules |
| Failure Mode Analysis | ✅ Complete | Critical scenarios, survival mode |
| **Credential Encryption** | ✅ Complete | Fernet + PBKDF2, OS keyring, rotation |
| **Bootstrap Sequence** | ✅ Complete | 6-phase flow, self-healing |

---

## 4. Implementation Roadmap (Updated)

### Phase 1: Core Package (Week 1-2)
- [x] Research packaging options
- [x] Design bootstrap sequence
- [x] Design credential encryption
- [ ] Create minimal Python runtime bundle
- [ ] Implement environment detector
- [ ] Build provider fallback chain
- [ ] Test on: Docker, bare metal, low-RAM VM

### Phase 2: Identity Resilience (Week 3)
- [ ] Multi-repo backup strategy
- [ ] Encrypted credential storage implementation
- [ ] Automatic identity restoration
- [ ] Test recovery scenarios

### Phase 3: Adaptation & Hardening (Week 4)
- [ ] Resource-based feature toggling
- [ ] Survival mode implementation
- [ ] Failure injection testing
- [ ] Recovery procedure validation

---

## 5. Research Artifacts

### Files Created/Updated:
1. `/opt/development/memory/2026-02-21.md` - This research log
2. `/opt/development/NXS-DEV-GUIDE.md` - Development rules (reference)
3. `/opt/development/RESEARCH-TASK-INDEX.md` - Task tracking (R013 updated)

### Code Samples:
- `CredentialVault` - Fernet-based encryption
- `OSKeyringVault` - OS-native storage
- `NXSBootstrap` - Bootstrap coordinator
- `SelfHealingMonitor` - Continuous monitoring

---

## 6. Next Research Priority

R013 is now **substantially complete**. Remaining work is implementation, not research.

**Recommended next actions:**
1. Begin Phase 1 implementation (if/when permitted)
2. Create test environment matrix
3. Draft deployment documentation

**Alternative new research tasks (if needed):**
- R014: Frontend Framework Selection (Vue vs Alpine.js deep dive)
- R015: Doctor Implementation Language (Go vs Python benchmarking)
- R016: Extension Loading Mechanism (dynamic module system)

---

## Sources

1. Python Cryptography Documentation - Fernet symmetric encryption
2. OWASP Password Storage Cheat Sheet - PBKDF2 iterations
3. Keyring Package Documentation - OS-native credential storage
4. PyInstaller Documentation - Self-extracting archives
5. Docker Security Best Practices - Distroless containers

---

*Session ended: 2026-02-21T20:35:00+08:00*
*Resources used: 1.4GB/3.8GB RAM (37%), 9.6GB/40GB disk (24%)*
*Sub-agents used: 0/2*
