# NXS Research Log

## Research Session: 2026-02-22 (Midday - Continuous Improvement)

### Cron-Triggered Research Review

**Timestamp:** 2026-02-22T12:27:00+08:00

---

## Executive Summary

Reviewed ongoing research tasks (R000-R017). Selected 3 under-explored tasks for deeper analysis:
- **R004/R005** - Voice System Integration (High Priority)
- **R007** - URL Frontend Design (High Priority)
- **R015** - Non-LLM Mundane Task Scripts (Medium Priority)

**Improvements Found:** 10 refinements across 3 tasks
**Files Updated:** 2 (this log, RESEARCH-TASK-INDEX.md)

---

## Task R004/R005: Voice System Integration - Refinements

### Current Status
R004 (XTTS-v2) and R005 (Whisper) have basic technology selections but lack integration architecture details, resource management strategies, and fallback mechanisms.

### Refinements Identified

#### 1. **Voice Pipeline State Machine** (New)
**Gap Found:** No clear state management for voice processing across capture → transcription → LLM → synthesis → output.

**Refinement:** Define explicit pipeline states with timeout and recovery:
```
States:
IDLE → LISTENING (VAD trigger)
LISTENING → PROCESSING (silence detected)
PROCESSING → THINKING (STT complete)
THINKING → SYNTHESIZING (LLM response ready)
SYNTHESIZING → SPEAKING (TTS audio ready)
SPEAKING → IDLE (playback complete)

Error States:
TIMEOUT: Return to IDLE after 30s in any state
STT_FAIL: Skip to THINKING with empty transcript
TTS_FAIL: Send text response instead of voice
```

**State Persistence:**
- Current state stored in memory with timestamp
- On crash/recovery: resume from last known state or reset to IDLE
- State transitions logged for debugging

**Benefit:** Clear failure recovery, predictable behavior, debuggable flow.

#### 2. **Tiered Voice Model Hot/Warm/Cold Loading** (New)
**Gap Found:** Voice models always loaded or always on-demand. No middle ground for responsive but resource-efficient operation.

**Refinement:** Implement 3-tier model state management:
| Tier | State | RAM | Activation Time | Use Case |
|------|-------|-----|-----------------|----------|
| **HOT** | Loaded in GPU/VRAM | 100% | <100ms | Active conversation |
| **WARM** | Loaded in RAM | 50% | 1-3s | Recent voice activity |
| **COLD** | On disk only | 0% | 5-15s | No recent voice use |

**Transition Logic:**
- HOT→WARM: 5 minutes of voice inactivity
- WARM→COLD: 30 minutes of voice inactivity
- COLD→WARM: Voice request received (async preload)
- WARM→HOT: VAD trigger detected

**Benefit:** Responsive voice interaction without constant resource drain.

#### 3. **Voice Quality Fallback Chain** (New)
**Gap Found:** Single point of failure if XTTS-v2 fails. No degraded-but-functional fallback.

**Refinement:** 3-tier quality fallback:
```
Primary: XTTS-v2 (1GB, excellent quality, voice cloning)
  ↓ Fail
Fallback: Piper TTS (100MB, good quality, fast)
  ↓ Fail
Emergency: System espeak-ng (10MB, robotic, always works)
```

**Failure Detection:**
- XTTS: Timeout >10s, OOM error, model load failure
- Piper: Timeout >3s, audio generation error
- espeak-ng: Synchronous, always succeeds

**User Notification:**
- Piper fallback: "Using lightweight voice mode"
- espeak fallback: "Voice system degraded, using emergency synthesizer"

**Benefit:** Voice always works, even in degraded conditions.

---

## Task R007: URL Frontend Design - Refinements

### Current Status
R007 has framework selection (Alpine.js) and basic architecture but lacks specific optimization strategies, offline capabilities, and real-time protocol details.

### Refinements Identified

#### 4. **WebSocket Compression Strategy** (New)
**Gap Found:** No bandwidth optimization for frontend-backend communication. Chat history and large messages waste bandwidth.

**Refinement:** Implement per-message deflate compression:
```javascript
// Server-side (Node.js ws library)
const WebSocket = require('ws');
const wss = new WebSocket.Server({
  perMessageDeflate: {
    zlibDeflateOptions: {
      chunkSize: 1024,
      memLevel: 7,
      level: 3  // Balance: speed vs compression
    },
    clientNoContextTakeover: true,  // Save server memory
    serverNoContextTakeover: true
  }
});
```

**Compression Thresholds:**
- Messages < 256 bytes: No compression (overhead not worth it)
- Messages 256B-10KB: Level 3 (fast, moderate compression)
- Messages > 10KB: Level 6 (better compression for large content)

**Expected Savings:**
- Chat messages: ~40-60% reduction
- Code blocks: ~70-80% reduction
- JSON state sync: ~50-70% reduction

**Benefit:** Reduced bandwidth, faster updates, lower latency on slow connections.

#### 5. **Progressive Web App Offline Strategy** (New)
**Gap Found:** Frontend requires constant connectivity. No offline queue or sync capability.

**Refinement:** PWA with offline message queue:
```javascript
// Service Worker Strategy
const CACHE_STRATEGIES = {
  // App shell: Cache first, always serve from cache
  shell: CacheFirst,
  
  // API responses: Network first, fallback to cache
  api: NetworkFirst,
  
  // WebSocket messages: Queue when offline, sync when online
  messages: QueueAndSync
};
```

**Offline Behavior:**
1. User types message while offline
2. Message stored in IndexedDB with timestamp
3. Visual indicator: "Queued - will send when online"
4. Connection restored → automatic sync
5. Conflicts resolved by timestamp (last-write-wins)

**Sync Protocol:**
```javascript
{
  type: 'sync',
  queued: [
    {id: 'msg-001', timestamp: '...', content: '...'},
    {id: 'msg-002', timestamp: '...', content: '...'}
  ],
  since: 'last-sync-timestamp'
}
```

**Benefit:** UX resilience - works even with intermittent connectivity.

#### 6. **Viewport-Aware Message Virtualization** (New)
**Gap Found:** Long conversations load all messages into DOM. Memory and performance degrade over time.

**Refinement:** Virtual scrolling for message history:
```javascript
// Only render visible messages + buffer
const VIRTUAL_CONFIG = {
  itemHeight: 80,        // Average message height
  overscan: 5,           // Render 5 above/below viewport
  maxTotalHeight: 100000 // Estimated total scroll height
};
```

**Implementation:**
- Calculate total scroll height from message count
- Render only visible messages (viewport ± overscan)
- Recycle DOM nodes for new messages
- Load history chunks on scroll (pagination)

**Chunk Loading:**
- Initial: Last 50 messages
- Scroll up: Load previous 50
- Maximum: Keep 200 in memory, archive older to disk

**Benefit:** Constant memory usage regardless of conversation length.

---

## Task R015: Non-LLM Mundane Task Scripts - Refinements

### Current Status
R015 has basic architecture but lacks concrete script specifications, security sandbox details, and integration patterns.

### Refinements Identified

#### 7. **Script Capability Sandbox** (New)
**Gap Found:** No clear security model for script execution. Scripts could potentially harm system.

**Refinement:** 6-tier capability system:
| Level | Name | Permissions | Examples |
|-------|------|-------------|----------|
| **0** | NONE | Read-only console | Logging, status display |
| **1** | READ_FS | Read files in workspace | File listing, reading configs |
| **2** | WRITE_FS | Write files in workspace | Log rotation, data export |
| **3** | READ_EXT | Read external resources | API polling, git status |
| **4** | WRITE_EXT | Write external resources | Git sync, API posting |
| **5** | EXECUTE | Spawn subprocesses | Image conversion, compression |
| **6** | SYSTEM | Full system access | Package install, system config |

**Declaration:**
```yaml
#!/usr/bin/env node
# @nxs-capability: READ_FS, WRITE_FS
# @nxs-timeout: 30000
# @nxs-memory: 128MB
```

**Enforcement:**
- Parse YAML header before execution
- Drop capabilities via Linux capabilities or seccomp
- Violation → immediate termination + alert

**Benefit:** Defense in depth - scripts can't exceed declared permissions.

#### 8. **Script Registry Auto-Discovery** (New)
**Gap Found:** Scripts scattered in filesystem. No centralized registry or discovery mechanism.

**Refinement:** Auto-discovery with metadata indexing:
```
~/.openclaw/scripts/
  index.json              # Auto-generated registry
  file-watcher/
    script.js
    manifest.yaml         # Human-readable metadata
  log-rotator/
    script.js
    manifest.yaml
```

**manifest.yaml format:**
```yaml
name: log-rotator
version: 1.0.0
description: Rotate and compress old log files
capabilities: [READ_FS, WRITE_FS]
triggers:
  - type: cron
    schedule: "0 0 * * *"  # Daily at midnight
  - type: event
    event: disk.full
inputs:
  - name: max_age_days
    type: number
    default: 7
outputs:
  - name: files_rotated
    type: number
```

**Discovery Process:**
1. Scan `~/.openclaw/scripts/*/` directories
2. Parse manifest.yaml in each
3. Generate index.json with all metadata
4. Watch for filesystem changes, auto-reindex

**Benefit:** Scripts self-document, easily discoverable, manageable at scale.

#### 9. **Event-Driven Script Triggering** (New)
**Gap Found:** Scripts only run on cron schedule. No event-based reactive execution.

**Refinement:** Event bus for reactive script execution:
```javascript
// Event types
const EVENTS = {
  // System events
  'system.disk.full': {threshold: '85%'},
  'system.memory.high': {threshold: '75%'},
  'system.cpu.high': {threshold: '80%'},
  
  // File events
  'file.created': {path: '/watch/path'},
  'file.modified': {path: '/watch/path'},
  
  // Git events
  'git.push': {repo: 'origin'},
  'git.pull': {repo: 'origin'},
  
  // API events
  'api.webhook': {endpoint: '/hooks/github'},
  
  // Custom events
  'custom.alert': {source: 'any'}
};
```

**Event Bus Architecture:**
```
Event Source → Event Bus → Filter → Script Executor
                  ↓
              Persistence (for replay)
```

**Trigger Matching:**
```yaml
triggers:
  - type: event
    event: system.disk.full
    condition: "threshold > 90%"
    debounce: 300  # seconds
```

**Benefit:** Reactive automation - respond immediately to conditions, not just on schedule.

#### 10. **Script Result Caching** (New)
**Gap Found:** Scripts rerun even when inputs haven't changed. Wasted computation.

**Refinement:** Deterministic caching for idempotent scripts:
```javascript
// Cache key = hash(script_path + inputs + dependencies)
const cacheKey = hash({
  script: '/scripts/git-sync.js',
  inputs: {repo: 'origin', branch: 'main'},
  deps: ['/workspace/file-a.txt', '/workspace/file-b.txt']
});
```

**Cache Policy:**
```yaml
cache:
  enabled: true
  ttl: 3600  # seconds
  invalidate_on:
    - file_change: ['/workspace/*.txt']
    - time: '0 0 * * *'  # Daily invalidation
```

**Cache Storage:**
- Results stored in `~/.openclaw/cache/scripts/`
- Metadata: execution time, exit code, output, timestamp
- LRU eviction when cache > 100MB

**Benefit:** Faster repeated operations, reduced resource usage for common tasks.

---

## Cross-Cutting Improvements

### R004/R005 + R007 Integration
Voice system and frontend must coordinate:
- Frontend shows voice state (listening/speaking)
- Voice pipeline errors displayed in UI
- PWA offline queue includes voice messages

### R015 + R006 Integration
The Doctor can trigger mundane scripts:
- `system.disk.full` → log-rotator script
- `system.memory.high` → cache-cleanup script
- Scripts become Doctor's automated hands

---

## Updated Task Status

| Task | Improvements | Key Refinements |
|------|--------------|-----------------|
| R004/R005 | 3 | Pipeline state machine, tiered loading, quality fallback |
| R007 | 3 | WebSocket compression, PWA offline, message virtualization |
| R015 | 4 | Capability sandbox, auto-discovery, event triggers, caching |
| Previous | 32 | (from earlier sessions) |
| **Total** | **42** | Across all research tasks |

---

## Files Updated

1. `/opt/development/memory/2026-02-22-midday.md` — This research log
2. `/opt/development/RESEARCH-TASK-INDEX.md` — Added R004/R005, R007, R015 refinements

---

## Backup Status

Research results will be backed up to GitHub via API after session completion.

---

*Session completed: 2026-02-22T12:35:00+08:00*

**Researcher:** Tenet Ashmier Manju (NXS Development Agent)  
**Hardware Usage:** 35-40% RAM, 26% disk (within limits)  
**Sub-agents Used:** 0/2

**Refinements Documented:** 10 improvements across 3 research tasks  
**Status:** Continuous improvement mode — all tasks remain Ongoing
