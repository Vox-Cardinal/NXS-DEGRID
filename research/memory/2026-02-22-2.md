# NXS Research Log

## Research Session: 2026-02-22 (Late Morning - Continuous Improvement)

### Cron-Triggered Research Review

**Timestamp:** 2026-02-22T10:57:00+08:00

---

## Executive Summary

Reviewed ongoing research tasks (R000-R015). Selected 3 tasks for deeper analysis:
- **R008** - Tailscale Integration (High Priority)
- **R013** - Survival Package Design (Critical Priority)
- **R002** - Multi-Instance Coordination (Critical Priority)

**Improvements Found:** 10 refinements across 3 tasks
**Files Updated:** 3 (this log, RESEARCH-TASK-INDEX.md, DECISION-LOG.md)

---

## Task R008: Tailscale Integration - Refinements

### Current Status
R008 covers secure mesh networking for distributed NXS instances. Previous research identified Tailscale as the primary solution but lacked detail on high availability and failover mechanisms.

### Refinements Identified

#### 1. **Tailscale High Availability Architecture** (New)
**Gap Found:** No documented failover strategy for when a Tailscale node goes offline.

**Refinement:** Design NXS Tailscale HA using overlapping subnet routers:

```
NXS Instance A (Primary)    NXS Instance B (Standby)    NXS Instance C (Standby)
     ↓                              ↓                           ↓
Advertise: 100.64.0.0/10    Advertise: 100.64.0.0/10    Advertise: 100.64.0.0/10
     ↓                              ↓                           ↓
     └──────────────────┬───────────────────┘
                        ↓
               Tailscale Control Plane
                        ↓
         Automatic Failover (15s detection)
```

**Key Findings from Tailscale Docs:**
- Failover occurs automatically when primary offline >15 seconds
- Oldest-registered connector becomes primary (deterministic)
- Regional routing available for Premium/Enterprise plans
- In-region load balancing spreads traffic across connectors

**Benefit:** NXS instances can survive individual node failures with automatic traffic redirection.

#### 2. **DERP Region-Aware Routing** (New)
**Gap Found:** No consideration of geographic distribution for global NXS deployment.

**Refinement:** Implement DERP region awareness:
- Each NXS instance reports latencies to nearest DERP servers
- Control plane assigns clients to nearest regional connector
- Automatic re-evaluation of routing preferences
- Cross-region failover if local region unavailable

**Benefit:** Optimal latency for global NXS mesh; automatic disaster recovery across regions.

#### 3. **Tailscale + Headscale Hybrid** (Enhancement)
**Gap Found:** Full dependency on Tailscale control plane creates single point of failure.

**Refinement:** Design hybrid control plane strategy:
- Primary: Tailscale official control plane (reliable, managed)
- Fallback: Self-hosted Headscale instance (SQLite backend)
- Migration path: Export auth keys, re-register with Headscale
- Decision matrix for when to switch:

| Condition | Action |
|-----------|--------|
| Tailscale outage >5 min | Alert only |
| Tailscale outage >30 min | Prepare Headscale fallback |
| Tailscale account suspended | Emergency Headscale migration |
| Self-sovereignty required | Planned Headscale migration |

**Benefit:** Independence from external service availability; path to full self-hosting.

---

## Task R013: Survival Package Design - Refinements

### Current Status
R013 research covers one-command deployment with minimal setup. Previous refinements included delta updates, signature verification, and bootstrap states.

### Refinements Identified

#### 4. **Cross-Platform Bootstrap Detection** (New)
**Gap Found:** Bootstrap sequence assumes Linux environment. No Windows/macOS support documented.

**Refinement:** Design platform detection matrix:

```javascript
const platformProfiles = {
  'linux-x64': {
    packageFormat: 'tar.gz',
    binaryExt: '',
    initSystem: ['systemd', 'openrc', 'sysvinit'],
    shell: '/bin/bash',
    paths: { config: '~/.nxs', logs: '/var/log/nxs' }
  },
  'linux-arm64': {
    packageFormat: 'tar.gz',
    binaryExt: '',
    initSystem: ['systemd'],
    shell: '/bin/bash',
    paths: { config: '~/.nxs', logs: '/var/log/nxs' }
  },
  'darwin-x64': {
    packageFormat: 'tar.gz',
    binaryExt: '',
    initSystem: ['launchd'],
    shell: '/bin/zsh',
    paths: { config: '~/Library/Application Support/NXS', logs: '~/Library/Logs/NXS' }
  },
  'win32-x64': {
    packageFormat: 'zip',
    binaryExt: '.exe',
    initSystem: ['windows-service', 'nssm'],
    shell: 'powershell.exe',
    paths: { config: '%APPDATA%\\NXS', logs: '%PROGRAMDATA%\\NXS\\Logs' }
  }
};
```

**Bootstrap adaptation:**
- Detect platform at runtime
- Select appropriate package variant
- Use platform-native paths and services
- Cross-platform dependency management

**Benefit:** NXS can deploy to any common platform without modification.

#### 5. **Dependency Bundling Strategy** (Enhancement)
**Gap Found:** Unclear which dependencies should be bundled vs downloaded.

**Refinement:** Define 3-tier dependency strategy:

| Tier | Contents | Bundled? | Rationale |
|------|----------|----------|-----------|
| **Core** | Node.js runtime, NXS binaries | Yes | Cannot function without |
| **Essential** | XTTS model (~1GB), Whisper model (~150MB) | Optional | Large but critical for voice |
| **On-Demand** | Browser binaries, extra models | No | Download when needed |

**Bundle variants:**
- `nxs-minimal.tar.gz` (~50MB): Core only
- `nxs-standard.tar.gz` (~200MB): Core + essential models
- `nxs-full.tar.gz` (~1.5GB): Everything included

**Benefit:** Users choose bundle size based on bandwidth constraints; minimal package for quick recovery.

#### 6. **Bootstrap Verification Checklist** (Enhancement)
**Gap Found:** No systematic verification that bootstrap succeeded.

**Refinement:** Create post-bootstrap verification protocol:

```bash
#!/bin/bash
# nxs-verify.sh - Run after bootstrap

echo "=== NXS Bootstrap Verification ==="

# 1. Binary integrity
echo -n "Checking binary signatures... "
nxs --version >/dev/null 2>&1 && echo "OK" || echo "FAIL"

# 2. Configuration load
echo -n "Checking config load... "
nxs config validate && echo "OK" || echo "FAIL"

# 3. LLM provider connectivity
echo -n "Checking LLM provider... "
nxs doctor check-provider && echo "OK" || echo "FAIL"

# 4. Tailscale mesh (if configured)
echo -n "Checking mesh connectivity... "
nxs mesh status && echo "OK" || echo "SKIP (not configured)"

# 5. Voice system (if included)
echo -n "Checking voice system... "
nxs voice test && echo "OK" || echo "SKIP (not included)"

# 6. Storage permissions
echo -n "Checking storage... "
touch ~/.nxs/.write-test && rm ~/.nxs/.write-test && echo "OK" || echo "FAIL"

echo "=== Verification Complete ==="
```

**Benefit:** Clear pass/fail indicators for bootstrap success; identifies specific failures.

---

## Task R002: Multi-Instance Coordination - Refinements

### Current Status
R002 covers running NXS everywhere, sharing state, surviving failures. Previous research covered Git-based sync and split-brain prevention.

### Refinements Identified

#### 7. **Conflict-Free Replicated Data Type (CRDT) State** (New)
**Gap Found:** Git-based last-write-wins can lose data during concurrent edits.

**Refinement:** Design CRDT-based state for specific data types:

**CRDT-appropriate data:**
- Message logs (append-only)
- Configuration changes (register with timestamp)
- Task queues (add-wins set)
- Presence indicators (LWW register)

**Implementation:**
```javascript
// Example: CRDT message log
const MessageLog = {
  type: 'G-Set',  // Grow-only set
  add: (set, message) => ({
    ...set,
    [message.id]: {
      ...message,
      vectorClock: incrementClock(set.clock, nodeId)
    }
  }),
  merge: (a, b) => ({ ...a, ...b })  // Set union
};
```

**Git for:** Large files, code, binary assets (where CRDTs inefficient)
**CRDT for:** Real-time collaborative state (messages, tasks, presence)

**Benefit:** No data loss during concurrent edits; automatic conflict resolution.

#### 8. **Instance Capability Registry** (New)
**Gap Found:** No mechanism for instances to advertise their capabilities.

**Refinement:** Design capability registry for work distribution:

```yaml
# ~/.nxs/capabilities.yaml
instance_id: nxs-prod-01
capabilities:
  compute:
    gpu: true
    gpu_model: "NVIDIA RTX 4090"
    ram_gb: 64
    cpu_cores: 16
  services:
    - voice_synthesis    # XTTS available
    - speech_recognition # Whisper available
    - browser_automation # Playwright available
    - image_generation   # ComfyUI available
  network:
    bandwidth_mbps: 1000
    tailscale_ip: "100.64.1.10"
    public_endpoints: []
  reliability:
    uptime_24h: 0.998
    avg_response_ms: 45
```

**Work distribution algorithm:**
1. Task arrives with requirements (needs GPU, needs voice, etc.)
2. Query capability registry for matching instances
3. Score by: capability match, current load, latency
4. Route to best instance
5. Update load metrics

**Benefit:** Optimal task placement; automatic failover to capable instances.

#### 9. **Epidemic Broadcast for State Gossip** (New)
**Gap Found:** Git-based sync requires central repository; no peer-to-peer state propagation.

**Refinement:** Implement gossip protocol for fast state propagation:

```
Instance A ──► Instance B ──► Instance C
     ▲              │              │
     └──────────────┴──────────────┘
              (gossip loop)
```

**Protocol:**
- Each instance maintains vector clock of known state
- Periodic gossip: "I have versions [A:5, B:3, C:7]"
- Receiver requests missing versions
- Anti-entropy: reconcile differences

**Use for:** Presence, health status, small state updates
**Not for:** Large files, binary data (use Git)

**Benefit:** Sub-second state propagation; works without central repository.

#### 10. **Mesh Quorum for Split-Brain Resolution** (Enhancement)
**Gap Found:** Expiring lock files may not handle network partitions gracefully.

**Refinement:** Implement quorum-based partition detection:

**Quorum rules:**
- Minimum 3 instances for quorum (tolerates 1 failure)
- Partition detected when <50% of known instances reachable
- Smaller partition enters "read-only survival mode"
- Larger partition continues normal operation
- Automatic reconciliation when partition heals

**Survival mode restrictions:**
- Accept queries, no state mutations
- Queue mutations for later sync
- Alert user of partition status

**Benefit:** Clear behavior during network splits; automatic recovery.

---

## Cross-Cutting Improvements

### Research Documentation Consolidation
**Gap Found:** Research findings scattered across multiple files; hard to find specific information.

**Refinement:** Create searchable index structure:
- `/opt/development/memory/INDEX.md` - Master index with tags
- `/opt/development/memory/BY-TOPIC/` - Symlinks/sections by topic
- `/opt/development/memory/BY-DATE/` - Chronological access

**Benefit:** Faster research lookup; prevents duplicate research.

---

## Updated Task Status

| Task | Improvements | Key Refinements |
|------|--------------|-----------------|
| R008 | 3 | HA failover, DERP routing, Headscale hybrid |
| R013 | 3 | Cross-platform, dependency tiers, verification |
| R002 | 4 | CRDT state, capability registry, gossip, quorum |
| Meta | 1 | Documentation index |

---

## Files Updated

1. `/opt/development/memory/2026-02-22.md` — This research log (appended)
2. `/opt/development/RESEARCH-TASK-INDEX.md` — Added refinements summary
3. `/opt/development/DECISION-LOG.md` — Added R008/R013/R002 refinements

---

## Backup Status

Research results will be backed up to GitHub via API after session completion.

---

*Session completed: 2026-02-22T11:15:00+08:00*

**Researcher:** Tenet Ashmier Manju (NXS Development Agent)  
**Hardware Usage:** 38% RAM, 26% disk (within limits)  
**Sub-agents Used:** 0/2

**Refinements Documented:** 10 improvements across 3 research tasks  
**Status:** Continuous improvement mode — all tasks remain Ongoing
